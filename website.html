<!DOCTYPE html>
<html lang="ckb" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø¦ÛŒØ¦Ø§ÛŒÛŒ Ú©ÙˆØ±Ø¯ÛŒ </title>
    <!-- FAVICON: The sun emoji (â˜€ï¸) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>â˜€ï¸</text></svg>">
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* General Setup - Black & Gray Aesthetic */
        :root {
            --primary-black: #000000;
            --secondary-gray: #4A4A4A;
            --primary-blue: #007AFF; 
            --background-light: #F2F2F7; 
            --card-background: #FFFFFF;
            --text-dark: #1D1D1F; 
            --border-color: #D1D1D6;
            --bubble-ai: #E5E5EA; 
            --subtle-gray: #6D6D72;
            --warning-red: #FF3B30;
            --chat-bubble-user: #1A1A1A; 
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif;
            background-color: var(--background-light); 
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            color: var(--text-dark);
            font-weight: 500; 
        }

        /* Custom Alert Modal */
        .custom-alert {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .alert-content {
            background: var(--card-background);
            padding: 20px 30px;
            border-radius: 12px;
            text-align: right;
            max-width: 90%;
            direction: rtl;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        .alert-title {
            font-weight: 700;
            font-size: 20px;
            margin-bottom: 10px;
            color: var(--warning-red);
        }

        .alert-content p {
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .alert-content button {
            background-color: var(--primary-black);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            float: left; 
            transition: opacity 0.2s;
        }
        .alert-content button:hover {
            opacity: 0.9;
        }

        /* --- RESPONSIVE CONTAINER STYLES --- */
        .chat-container, .auth-container {
            width: 95%; 
            max-width: 1200px; 
            height: 100%;
            background-color: var(--card-background);
            border-radius: 16px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08); 
            display: flex;
            flex-direction: column;
            overflow: hidden;
            margin-top: 15px;
            margin-bottom: 15px;
        }
        
        @media (max-width: 800px) {
            .chat-container, .auth-container {
                max-width: 100%; 
                width: 100%;
                border-radius: 0;
                margin: 0;
                box-shadow: none;
            }
        }
        /* --- END RESPONSIVE CONTAINER STYLES --- */


        /* AUTH SCREEN STYLES */
        .auth-container {
            justify-content: center;
            align-items: center;
            padding: 30px;
            text-align: center;
        }

        .auth-card {
            background-color: var(--card-background);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05); 
            width: 100%;
            max-width: 350px;
        }

        .auth-card h2 {
            margin-bottom: 30px;
            font-size: 26px; 
            font-weight: 700; 
            color: var(--text-dark);
        }

        .auth-button {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            padding: 14px;
            margin-bottom: 12px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 17px; 
            font-weight: 600; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
        }

        .google-icon {
            width: 20px;
            height: 20px;
            margin-left: 10px;
            flex-shrink: 0;
            object-fit: contain;
        }
        
        .auth-button:hover {
            opacity: 0.95; 
            transform: translateY(-2px); 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1); 
        }
        .auth-button:active {
            transform: translateY(0); 
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1); 
        }

        .google-btn {
            background-color: var(--primary-black); 
            color: white;
            margin-bottom: 30px; 
        }
        
        .anonymous-btn {
            background-color: var(--secondary-gray); 
            color: white;
            border: 1px solid var(--primary-black);
        }

        .separator {
            display: flex;
            align-items: center;
            text-align: center;
            margin: 15px 0;
            color: var(--subtle-gray);
            font-size: 14px;
        }
        .separator::before,
        .separator::after {
            content: '';
            flex: 1;
            border-bottom: 1px solid var(--border-color);
        }
        .separator:not(:empty)::before {
            margin-right: .25em;
        }
        .separator:not(:empty)::after {
            margin-left: .25em;
        }


        /* CHAT HEADER */
        .header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            direction: rtl; 
        }

        .title-group {
            display: flex;
            align-items: center;
        }

        .title-group h1 {
            font-size: 22px;
            font-weight: 700;
            margin: 0;
            margin-right: 10px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap; 
            justify-content: flex-start;
        }
        
        @media (max-width: 450px) {
            .header-actions {
                width: 100%;
                margin-top: 10px;
            }
            .header {
                flex-direction: column;
                align-items: flex-end; 
            }
        }


        .header-button {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
            border: none;
            flex-grow: 1; 
        }
        
        /* Specific Button Styling */
        #upgrade-button {
            background-color: transparent; 
            color: var(--primary-blue); 
            border: none;
            padding: 8px 0; 
            text-decoration: underline; 
            font-weight: 500; 
            transition: color 0.2s;
            flex-grow: 0; 
        }
        #upgrade-button:hover {
            opacity: 1; 
            color: #0056b3; 
        }

        #new-chat-button {
            background-color: var(--primary-blue);
            color: white;
        }

        #logout-button {
            background-color: var(--warning-red); 
            color: white;
        }

        #load-history-button {
            background-color: var(--secondary-gray); 
            color: white;
        }
        
        .header-button i {
            margin-left: 5px;
            font-size: 18px;
        }
        .header-button:hover:not(#upgrade-button) {
            opacity: 0.85;
        }

        /* MESSAGE AREA */
        .message-area {
            flex-grow: 1;
            padding: 20px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 15px;
            scroll-behavior: smooth;
        }

        /* CHAT MESSAGES */
        .message {
            display: flex;
            align-items: flex-start;
            max-width: 90%;
        }
        
        .message .icon {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            flex-shrink: 0;
            font-weight: normal; 
        }

        /* User Bubble/Icon Update */
        .message.user .icon {
            background-color: var(--chat-bubble-user); 
            color: white;
            margin-right: 10px;
            font-family: Arial, sans-serif;
            font-weight: bold;
        }
        .message.ai .icon {
            background-color: var(--bubble-ai);
            color: var(--text-dark);
            margin-left: 10px;
        }

        /* AI Bubble */
        .message.ai .ai-bubble-content {
            background-color: var(--bubble-ai);
            padding: 10px 15px;
            border-radius: 18px;
            border-top-right-radius: 0;
            line-height: 1.4;
            color: var(--text-dark);
            text-align: right;
            direction: rtl;
            display: flex;
            flex-direction: column;
            gap: 8px; 
            max-width: 100%;
        }

        /* User Bubble Update */
        .message.user .text-content {
            background-color: var(--chat-bubble-user); 
            color: white;
            padding: 10px 15px;
            border-radius: 18px;
            border-top-left-radius: 0;
            text-align: right;
            direction: rtl;
            max-width: 100%;
        }

        /* Image Display in Chat */
        .message-image {
            max-width: 100%;
            max-height: 300px;
            border-radius: 12px;
            margin-bottom: 5px;
            object-fit: contain;
        }
        .message.ai .ai-bubble-content .message-image {
            align-self: flex-start; /* Ensure AI images align left within RTL bubble */
        }
        .message.user .text-content .message-image {
             align-self: flex-end; /* Ensure User images align right within RTL bubble */
        }

        /* TTS Button inside AI bubble */
        .tts-button {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 5px 10px;
            border-radius: 10px;
            background-color: rgba(255, 255, 255, 0.7); 
            border: 1px solid var(--border-color);
            color: var(--text-dark);
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            width: fit-content;
            align-self: flex-start; 
        }
        .tts-button:hover {
            background-color: white;
        }
        .tts-button i {
            font-size: 16px;
            margin-left: 5px;
        }

        /* Loading indicator for TTS */
        .rotating-icon {
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }


        /* INPUT AREA */
        .input-wrapper {
            border-top: 1px solid var(--border-color);
            padding: 10px 20px;
            flex-shrink: 0;
            direction: rtl; 
            display: flex;
            flex-direction: column; 
            gap: 8px;
        }
        .input-area {
            display: flex;
            gap: 10px;
            width: 100%;
        }

        /* Image Preview Area */
        #image-preview-container {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding: 8px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            background-color: var(--bubble-ai);
        }
        #image-preview-container img {
            max-width: 80px;
            max-height: 80px;
            border-radius: 6px;
            margin-right: 10px;
        }
        #remove-image-button {
            background: none;
            border: none;
            color: var(--warning-red);
            font-size: 20px;
            cursor: pointer;
            padding: 5px;
        }


        #user-input {
            flex-grow: 1;
            padding: 10px 15px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            font-size: 16px;
            resize: none; 
            overflow: auto; 
            max-height: 100px; /* Maximum height for auto-resizing */
            min-height: 40px;
            text-align: right;
            direction: rtl;
            font-family: inherit;
            transition: height 0.1s ease-out;
        }

        /* Send Button Update (Includes Image Upload Button) */
        .input-controls {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        .input-controls button {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            color: white;
            font-size: 20px;
        }
        
        #send-button {
            background-color: var(--primary-black); 
        }
        #send-button:hover:not(:disabled) {
            background-color: var(--secondary-gray); 
        }
        #send-button:disabled {
            background-color: var(--subtle-gray); 
            cursor: not-allowed;
        }

        #upload-button {
            background-color: var(--primary-blue);
        }
        #upload-button:hover {
            background-color: #0056b3;
        }

        /* Footer Info */
        .footer-info {
            padding: 5px 20px;
            font-size: 12px;
            color: var(--subtle-gray);
            text-align: right;
            direction: rtl;
            border-top: 1px solid var(--border-color); 
        }
        
    </style>
    <script type="module">
        
        // ------------------ IMAGE ASSETS (Google "G" Logo SVG) ------------------
        const defaultGoogleLogoSvg = `
            <svg class="google-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 533.5 544.3">
                <path fill="#4285f4" d="M533.5 272.2c0-18.7-1.4-37.1-4.7-55H272.2v104.9h148.4c-6.2 33.7-25.5 63.8-53.1 82.3v68.1h87.7c51.5-47.5 81.6-118.1 81.6-200.3z"/>
                <path fill="#34a853" d="M272.2 544.3c73.7 0 135.5-24.5 180.6-66.8l-87.7-68.1c-24.6 16.5-56.1 26.6-92.9 26.6-71.1 0-131.2-48.4-153-113.8H20v68.1c44.8 88 136.2 149.8 252.2 149.8z"/>
                <path fill="#fbbc05" d="M119.2 328.7c-5.1-15.4-7.9-32.3-7.9-49.8s2.8-34.4 7.9-49.8V161H20c-15.6 31.8-24.3 67.4-24.3 107.9s8.7 76.1 24.3 107.9h99.2z"/>
                <path fill="#ea4335" d="M272.2 107.9c40.3 0 76.5 13.8 105 40.7l77.7-77.7C407.2 24.5 345.4 0 272.2 0 156.2 0 64.8 61.8 20 149.8l99.2 68.1c21.8-65.4 81.9-113.8 153-113.8z"/>
            </svg>
        `;
        const emptyLogoHtml = defaultGoogleLogoSvg; 

        // ------------------ FIREBASE CONFIGURATION (Mock values used if environment variables aren't defined) ------------------
        const userFirebaseConfig = {
            apiKey: "AIzaSyDoTAMAuFm8h9RFWk_C4BnqtwEis-RGor4",
            authDomain: "ai-kurdy.firebaseapp.com",
            projectId: "ai-kurdy",
            storageBucket: "ai-kurdy.firebasestorage.app",
            messagingSenderId: "1071066507145",
            appId: "1:1071066507145:web:46e894ecfab03cecf52358",
            measurementId: "G-044ZEW6C0G"
        };
        
        // ------------------ FIREBASE IMPORTS ------------------
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, GoogleAuthProvider, signInWithPopup, signOut, linkWithPopup, signInWithCredential } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, collection, query, addDoc, where, serverTimestamp, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // ------------------ GLOBAL VARIABLES FROM ENVIRONMENT ------------------
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-ai-kurdy-app-id'; 
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : userFirebaseConfig;
        // Check for the custom token provided by the environment
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

        let app, auth, db;
        let userId = null;
        
        // State for Image Upload
        let currentImageBase64 = null;
        let currentImageMimeType = null;
        const MAX_IMAGE_SIZE_BYTES = 5 * 1024 * 1024; // 5MB limit
        
        // --- WELCOME MESSAGE ---
        const WELCOME_MESSAGE_TEXT = 'Ø¨Û•Ø®ÛØ±Ø¨ÛÛŒØª! Ù…Ù† Ø¦ÛŒØ¦Ø§ÛŒÛŒ Ú©ÙˆØ±Ø¯ÛŒÙ€Ù…. Ú†Û†Ù† Ø¯Û•ØªÙˆØ§Ù†Ù… ÛŒØ§Ø±Ù…Û•ØªÛŒØª Ø¨Ø¯Û•Ù…ØŸ';
        // -----------------------
        
        // ** IMPORTANT: GEMINI API KEY DEFINITION **
        // You MUST replace "YOUR_GEMINI_API_KEY_HERE" with your actual Google Gemini API Key.
        // If the key is invalid, you will continue to receive HTTP 400 errors.
        const geminiApiKey = "AIzaSyDNc6-bEE5GpFt5uq_nTkQKAZPXjuKiXSw"; 

        // The system instruction for the Gemini Model
        const systemInstruction = "You are a helpful, conversational AI assistant. Your primary function is to communicate effectively in the user's language. If the user writes in Sorani Kurdish, respond in fluent Sorani Kurdish. If they write in another language, respond in that language. You can analyze images provided by the user and respond to image-related commands (e.g., describe, modify, identify). When generating a new image based on a command, respond with the image. Maintain a polite, supportive, and knowledgeable tone.";

        
        // ------------------ UI ELEMENTS ------------------
        const chatContainer = document.getElementById('chat-container');
        const authContainer = document.getElementById('auth-container');
        const messageArea = document.getElementById('message-area');
        const inputField = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const userIdDisplay = document.getElementById('user-id-display');
        const loadHistoryButton = document.getElementById('load-history-button');
        const newChatButton = document.getElementById('new-chat-button');
        const logoutButton = document.getElementById('logout-button');
        const upgradeButton = document.getElementById('upgrade-button');
        const imageUpload = document.getElementById('image-upload');
        const imagePreviewContainer = document.getElementById('image-preview-container');
        const imagePreview = document.getElementById('image-preview');
        const removeImageButton = document.getElementById('remove-image-button');
        

        // ------------------ CORE UTILITY FUNCTIONS ------------------
        
        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function pcmToWav(pcm16, sampleRate = 24000) {
            const numChannels = 1;
            const bytesPerSample = 2; 
            const blockAlign = numChannels * bytesPerSample;
            const byteRate = sampleRate * blockAlign;
            const dataLength = pcm16.length * bytesPerSample;

            const buffer = new ArrayBuffer(44 + dataLength);
            const dataView = new DataView(buffer);

            // RIFF chunk
            writeString(dataView, 0, 'RIFF');
            dataView.setUint32(4, 36 + dataLength, true); 
            writeString(dataView, 8, 'WAVE');

            // FMT sub-chunk
            writeString(dataView, 12, 'fmt ');
            dataView.setUint32(16, 16, true);  
            dataView.setUint16(20, 1, true);    
            dataView.setUint16(22, numChannels, true);
            dataView.setUint32(24, sampleRate, true);
            dataView.setUint32(28, byteRate, true);
            dataView.setUint16(32, blockAlign, true);
            dataView.setUint16(34, 16, true);  

            // Data sub-chunk
            writeString(dataView, 36, 'data');
            dataView.setUint32(40, dataLength, true);

            // Write PCM data
            let offset = 44;
            for (let i = 0; i < pcm16.length; i++, offset += 2) {
                dataView.setInt16(offset, pcm16[i], true); 
            }

            return new Blob([buffer], { type: 'audio/wav' });
        }
        
        /**
         * Dynamically adjusts the height of the input textarea based on its content.
         */
        function autoResizeInput() {
            inputField.style.height = 'auto'; 
            inputField.style.height = inputField.scrollHeight + 'px';
        }


        // Custom function to replace alert()
        function alertMessage(title, message) {
            const existingAlert = document.getElementById('custom-alert');
            if (existingAlert) existingAlert.remove();

            const alertDiv = document.createElement('div');
            alertDiv.id = 'custom-alert';
            alertDiv.className = 'custom-alert';
            alertDiv.innerHTML = `
                <div class="alert-content">
                    <div class="alert-title">${title}</div>
                    <p>${message}</p>
                    <button onclick="document.getElementById('custom-alert').remove()">Ø¨Ø§Ø´Û•</button>
                </div>
            `;
            document.body.appendChild(alertDiv);
        }

        // ------------------ IMAGE UPLOAD LOGIC ------------------

        imageUpload.addEventListener('change', handleImageUpload);
        removeImageButton.addEventListener('click', removeImage);
        
        /**
         * Converts uploaded file to Base64 and updates preview, with size check.
         */
        function handleImageUpload(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ ÙˆÛÙ†Û•', 'ØªÛ•Ù†Ù‡Ø§ Ø¯Û•ØªÙˆØ§Ù†ÛŒØª ÙØ§ÛŒÙ„ÛŒ ÙˆÛÙ†Û• (ÙˆÛ•Ú©ÙˆÙˆ PNG, JPEG) Ø¨Ø§Ø± Ø¨Ú©Û•ÛŒØª.');
                imageUpload.value = '';
                return;
            }
            
            // Check file size (Guardrail for 400 errors due to large payloads)
            if (file.size > MAX_IMAGE_SIZE_BYTES) {
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ù‚Û•Ø¨Ø§Ø±Û•', 'Ù‚Û•Ø¨Ø§Ø±Û•ÛŒ ÙˆÛÙ†Û•Ú©Û• Ù†Ø§Ø¨ÛØª Ù„Û• Ù¥ Ù…ÛÚ¯Ø§Ø¨Ø§ÛŒØª ØªÛÙ¾Û•Ú•ÛØª.');
                imageUpload.value = '';
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                // e.target.result is the Base64 data URL
                const base64Data = e.target.result;
                
                // Store Base64 data (remove prefix for API payload)
                const parts = base64Data.split(',');
                currentImageBase64 = parts.length > 1 ? parts[1] : base64Data;
                currentImageMimeType = file.type;

                // Update UI preview
                imagePreview.src = base64Data;
                imagePreviewContainer.style.display = 'flex';
                
                // Clear file input to allow uploading the same file again if needed
                imageUpload.value = '';
                
                // Focus on input to write the prompt
                inputField.focus(); 
            };
            reader.readAsDataURL(file);
        }

        /**
         * Clears the current image state and hides the preview.
         */
        function removeImage() {
            currentImageBase64 = null;
            currentImageMimeType = null;
            imagePreview.src = '';
            imagePreviewContainer.style.display = 'none';
        }

        // ------------------ LLM TTS FEATURE ------------------

        window.playTTS = async (text, ttsButton) => {
            if (geminiApiKey === "YOUR_GEMINI_API_KEY_HERE" || !geminiApiKey) {
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ú©Ù„ÛŒÙ„ÛŒ API', 'ØªÚ©Ø§ÛŒÛ• Ú©Ù„ÛŒÙ„ÛŒ Ú•Ø§Ø³ØªÛ•Ù‚ÛŒÙ†Û•ÛŒ Gemini API Ø¬ÛÚ¯ÛŒØ± Ø¨Ú©Û• Ù„Û• Ú©Û†Ø¯ÛŒ Ø³Û•Ø±Û•ØªØ§Ø¯Ø§ Ø¨Û† Ú©Ø§Ø±Ù¾ÛÚ©Ø±Ø¯Ù†ÛŒ TTS.');
                return;
            }

            const originalIcon = ttsButton.innerHTML;
            ttsButton.innerHTML = '<i class="material-icons rotating-icon">sync</i> loading...';
            ttsButton.disabled = true;

            const voiceName = "Kore"; 

            const payload = {
                contents: [{
                    parts: [{ text: `Say this text, using the appropriate language and tone: ${text}` }] 
                }],
                generationConfig: {
                    responseModalities: ["AUDIO"],
                    speechConfig: {
                        voiceConfig: {
                            prebuiltVoiceConfig: { voiceName: voiceName }
                        }
                    }
                },
            };
            
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${geminiApiKey}`;

            try {
                let response = null;
                let delay = 1000;
                for (let i = 0; i < 3; i++) {
                    try {
                        response = await fetch(apiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.ok) break;
                    } catch (e) {
                        console.warn(`TTS fetch failed (attempt ${i + 1}). Retrying in ${delay / 1000}s...`, e);
                    }
                    if (i < 2) await new Promise(resolve => setTimeout(resolve, delay *= 2));
                }
                
                if (!response || !response.ok) throw new Error("TTS API call failed after retries.");

                const result = await response.json();
                const part = result?.candidates?.[0]?.content?.parts?.[0];
                const audioData = part?.inlineData?.data;
                const mimeType = part?.inlineData?.mimeType;

                if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
                    const rateMatch = mimeType.match(/rate=(\d+)/);
                    const sampleRate = rateMatch ? parseInt(rateMatch[1], 10) : 24000;
                    
                    const pcmDataBuffer = base64ToArrayBuffer(audioData);
                    const pcm16 = new Int16Array(pcmDataBuffer);
                    const wavBlob = pcmToWav(pcm16, sampleRate);
                    const audioUrl = URL.createObjectURL(wavBlob);
                    
                    const audio = new Audio(audioUrl);
                    audio.play();

                    audio.onended = () => {
                        URL.revokeObjectURL(audioUrl); 
                        ttsButton.innerHTML = originalIcon;
                        ttsButton.disabled = false;
                    };

                    audio.onerror = (e) => {
                        console.error("Audio playback error:", e);
                        alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ù„ÛØ¯Ø§Ù†ÛŒ Ø¯Û•Ù†Ú¯', 'Ù†Ø§ØªÙˆØ§Ù†Ø±ÛØª Ø¯Û•Ù†Ú¯Û•Ú©Û• Ù„ÛØ¨Ø¯Ø±ÛØª. Ú•Û•Ù†Ú¯Û• ÙÛ†Ø±Ù…Ø§ØªÛ•Ú©Û• Ú©ÛØ´Û•ÛŒ Ù‡Û•Ø¨ÛØª.');
                        ttsButton.innerHTML = originalIcon;
                        ttsButton.disabled = false;
                    };
                    
                } else {
                    console.error("Invalid TTS response structure or missing audio data.", result);
                    alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ø¯Û•Ù†Ú¯', 'Ù‡ÛŒÚ† Ø¯Û•Ù†Ú¯ÛÚ© Ù†Û•Ø¯Û†Ø²Ø±Ø§ÛŒÛ•ÙˆÛ• ÛŒØ§Ù† ÙÛ†Ø±Ù…Ø§ØªÛ•Ú©Û• Ù‡Û•ÚµÛ•ÛŒÛ•.');
                }
            } catch (error) {
                console.error("TTS generation error:", error);
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ú¯Ø´ØªÛŒ', 'Ú©ÛØ´Û•ÛŒÛ•Ú© Ù„Û• Ø¯Ø±ÙˆØ³ØªÚ©Ø±Ø¯Ù†ÛŒ Ø¯Û•Ù†Ú¯Û•Ú©Û• Ú•ÙˆÙˆÛŒØ¯Ø§. Ù‡Û†Ú©Ø§Ø±: ' + error.message);
            } finally {
                if (ttsButton.disabled && ttsButton.innerHTML.includes('sync')) {
                    ttsButton.innerHTML = originalIcon;
                    ttsButton.disabled = false;
                }
            }
        };


        // ------------------ FIREBASE INITIALIZATION & AUTH ------------------
        function initializeFirebase() {
            if (!firebaseConfig.apiKey) {
                console.error("Firebase config is missing or incomplete. Authentication will not work.");
                document.getElementById('auth-error').textContent = "Ù‡Û•ÚµÛ•: Ú•ÛÚ©Ø®Ø³ØªÙ†Û•Ú©Ø§Ù†ÛŒ ÙØ§ÛŒÛ•Ø±Ø¨Û•ÛŒØ³ Ù†Ø§Ø¯Ø±ÙˆØ³ØªÙ†.";
                return;
            }
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
            
            // Start the auth flow
            handleInitialAuth();
        }

        /**
         * Handles initial sign-in: either with the custom environment token 
         * or automatically falls back to anonymous sign-in for external hosting (like GitHub Pages).
         */
        async function handleInitialAuth() {
            // Set up the listener immediately. It will handle the UI switch.
            setupAuthListener();

            // 1. Try to sign in with the Canvas environment's custom token (if available)
            if (initialAuthToken) {
                try {
                    console.log("Attempting sign-in with custom token...");
                    await signInWithCustomToken(auth, initialAuthToken);
                    return; // Authentication successful, stop here.
                } catch (error) {
                    console.error("Custom token sign-in failed:", error);
                    // If custom token fails, proceed to anonymous sign-in fallback.
                }
            }
            
            // 2. Fallback: If no custom token or sign-in failed, attempt anonymous sign-in.
            // This ensures the app starts immediately on platforms like GitHub Pages.
            try {
                console.log("Custom token missing or failed. Attempting anonymous sign-in fallback...");
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Automatic anonymous sign-in failed:", error);
                // The auth listener will be notified of the failed state, leaving the choice screen visible.
            }
        }

        // ------------------ AUTHENTICATION METHODS ------------------
        
        window.logout = async () => {
            try {
                window.chatHistory = [];
                messageArea.innerHTML = '';
                removeImage();
                await signOut(auth);
                alertMessage('Ú†ÙˆÙˆÙ†Û•Ø¯Û•Ø±Û•ÙˆÛ• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆ Ø¨ÙˆÙˆ', 'Ø¨Û• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆÛŒÛŒ Ù„Û• Ù‡Û•Ú˜Ù…Ø§Ø±Û•Ú©Û•Øª Ú†ÙˆÙˆÛŒØªÛ• Ø¯Û•Ø±Û•ÙˆÛ•. Ø¯Û•ØªÙˆØ§Ù†ÛŒØª Ø¯ÙˆØ¨Ø§Ø±Û• Ø¨Ú†ÛŒØªÛ• Ú˜ÙˆÙˆØ±Û•ÙˆÛ• ÛŒØ§Ù† ÙˆÛ•Ú© Ø¨ÛÙ†Ø§Ùˆ Ø¨Û•Ø±Ø¯Û•ÙˆØ§Ù… Ø¨ÛŒØª.');
            } catch (error) {
                console.error("Logout failed:", error);
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ú†ÙˆÙˆÙ†Û•Ø¯Û•Ø±Û•ÙˆÛ•', `Ù†Û•ØªÙˆØ§Ù†Ø±Ø§ Ù„Û• Ù‡Û•Ú˜Ù…Ø§Ø±Û•Ú©Û• Ø¨Ú†ÛŒØªÛ• Ø¯Û•Ø±Û•ÙˆÛ•: ${error.message}`);
            }
        };

        window.signInWithGoogle = async () => {
            try {
                const provider = new GoogleAuthProvider();
                await signInWithPopup(auth, provider);
            } catch (error) {
                if (error.code === 'auth/credential-already-in-use' && error.credential) {
                    try {
                        const credential = error.credential;
                        await signInWithCredential(auth, credential);
                        alertMessage('Ù„ÛŒÙ†Ú©Ú©Ø±Ø¯Ù† Ùˆ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆ Ø¨ÙˆÙˆ', 'Ø¦Û•Ù… Ø¦Û•Ú©Ø§ÙˆÙ†ØªÛ•ÛŒ Ú¯ÙˆÙˆÚ¯Úµ Ù¾ÛØ´ØªØ± Ø¨Û•Ú©Ø§Ø±Ù‡Ø§ØªØ¨ÙˆÙˆ. Ø¦ÛØ³ØªØ§ Ø¨Û• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆÛŒÛŒ Ú†ÙˆÙˆÛŒØªÛ• Ú˜ÙˆÙˆØ±Û•ÙˆÛ• Ùˆ Ú†ÛŒØªØ± Ø¨ÛÙ†Ø§Ùˆ Ù†ÛŒØª.');
                    } catch(e) {
                        console.error("Failed to merge conflicting sign-in:", e);
                        alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ•', `Ù‡Û•ÚµÛ•ÛŒ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ•ÛŒ Ú¯ÙˆÙˆÚ¯Úµ: Ø¦Û•Ù… Ø¦Û•Ú©Ø§ÙˆÙ†ØªÛ• Ø¨Û•Ø³ØªØ±Ø§ÙˆÛ•ØªÛ•ÙˆÛ• Ø¨Û• Ú•ÛÚ¯Ø§ÛŒÛ•Ú©ÛŒ ØªØ±ÛŒ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ• Ùˆ Ù†Û•ØªÙˆØ§Ù†Ø±Ø§ Ø¨Ú¯Û†Ú•Ø¯Ø±ÛØª. ${e.message}`);
                    }
                } else {
                    console.error("Google Sign-In failed:", error);
                    alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ•', `Ù‡Û•ÚµÛ•ÛŒ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ•ÛŒ Ú¯ÙˆÙˆÚ¯Úµ: ${error.message}`);
                }
            }
        };

        window.signInAnonymouslyUser = async () => {
            try {
                await signInAnonymously(auth);
            } catch (error) {
                console.error("Anonymous Sign-In failed:", error);
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ•', `Ù‡Û•ÚµÛ•ÛŒ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ•ÛŒ Ø¨ÛÙ†Ø§Ùˆ: ${error.message}`);
            }
        };

        window.upgradeToGoogle = async () => {
            if (!auth.currentUser || !auth.currentUser.isAnonymous) {
                alertMessage('Ù‡Û•ÚµÛ•', 'ØªÛ•Ù†Ù‡Ø§ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±Ø§Ù†ÛŒ Ø¨ÛÙ†Ø§Ùˆ Ø¯Û•ØªÙˆØ§Ù†Ù† Ø¦Û•Ú©Ø§ÙˆÙ†ØªÛŒØ§Ù† Ø¨Û•Ø±Ø² Ø¨Ú©Û•Ù†Û•ÙˆÛ•.');
                return;
            }

            try {
                const provider = new GoogleAuthProvider();
                await linkWithPopup(auth.currentUser, provider);
                alertMessage('Ø¨Û•Ø³ØªÙ†Û•ÙˆÛ• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆ Ø¨ÙˆÙˆ', 'Ù‡Û•Ú˜Ù…Ø§Ø±ÛŒ Ø¨ÛÙ†Ø§ÙˆÛŒ Ø¦ÛØ³ØªØ§Øª Ø¨Û• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆÛŒÛŒ Ø¨Û•Ø³ØªØ±Ø§ÙˆÛ•ØªÛ•ÙˆÛ• Ø¨Û• Ú¯ÙˆÙˆÚ¯Úµ.');
                
            } catch (error) {
                if (error.code === 'auth/credential-already-in-use' && error.credential) {
                    try {
                        const credential = error.credential;
                        await signInWithCredential(auth, credential);
                        alertMessage('Ù„ÛŒÙ†Ú©Ú©Ø±Ø¯Ù† Ùˆ Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆ Ø¨ÙˆÙˆ', 'Ù‡Û•Ú˜Ù…Ø§Ø±ÛŒ Ù¾ÛØ´ÙˆÙˆÛŒ Ú¯ÙˆÙˆÚ¯ÚµØª Ú†ÙˆÙˆÙ‡â€ŒØªÙ‡â€Œ Ú˜ÙˆÙˆØ±Û•ÙˆÛ•.');
                    } catch (e) {
                         console.error("Failed to sign in with conflicting credential:", e);
                         alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ø¨Û•Ø³ØªÙ†Û•ÙˆÛ•', `Ù†Û•ØªÙˆØ§Ù†Ø±Ø§ Ø¦Û•Ú©Ø§ÙˆÙ†ØªÛ• Ø¨Û•Ø³ØªØ±Ø§ÙˆÛ•Ú©Û• Ø¨Û•Ú©Ø§Ø± Ø¨Ù‡ÛÙ†Ø±ÛØª Ø¨Û† Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ•: ${e.message}`);
                    }
                    
                } else {
                    console.error("Account upgrade failed:", error);
                    alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ø¨Û•Ø³ØªÙ†Û•ÙˆÛ•', `Ù†Û•ØªÙˆØ§Ù†Ø±Ø§ Ø¦Û•Ú©Ø§ÙˆÙ†ØªÛŒ Ú¯ÙˆÙˆÚ¯Úµ Ø¨Ø¨Û•Ø³ØªØ±ÛØªÛ•ÙˆÛ•: ${error.message}`);
                }
            }
        };
        
        function isPersistentUser(user) {
            return user && !user.isAnonymous;
        }

        // ------------------ AUTH STATE LISTENER & UI MANAGEMENT ------------------
        function setupAuthListener() {

            onAuthStateChanged(auth, (user) => {
                if (user) {
                    userId = user.uid;
                    showAuthScreen(false); 
                    
                    const isAnonymous = user.isAnonymous;
                    const isPersistent = isPersistentUser(user);
                    
                    if (isPersistent && user.email) {
                        userIdDisplay.textContent = `Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ• Ø¨Û•: ${user.email} (Ø¨Û•Ø±Ø¯Û•ÙˆØ§Ù…)`;
                    } else if (isAnonymous) {
                        userIdDisplay.textContent = `Ù†Ø§Ø³Ù†Ø§Ù…Û•ÛŒ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±: ${userId} (Ø¨ÛÙ†Ø§Ùˆ - Ø¨Û Ù¾Ø§Ø´Û•Ú©Û•ÙˆØª)`;
                    } else {
                        userIdDisplay.textContent = `Ù†Ø§Ø³Ù†Ø§Ù…Û•ÛŒ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±: ${userId} (Ø¨Û•Ø±Ø¯Û•ÙˆØ§Ù…)`;
                    }

                    logoutButton.style.display = 'flex'; 
                    newChatButton.style.display = 'flex'; 

                    if (isPersistent) {
                        upgradeButton.style.display = 'none';
                        loadHistoryButton.style.display = 'flex'; 
                    } else { 
                        upgradeButton.style.display = 'flex'; 
                        loadHistoryButton.style.display = 'none'; 
                    }

                    setupChatSession(user);

                } else {
                    // User is not authenticated, show the choice screen
                    userId = null;
                    userIdDisplay.textContent = 'Ù†Ø§Ø³Ù†Ø§Ù…Û•ÛŒ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±: Ø¨ÛÙ†Ø§Ùˆ';
                    showAuthScreen(true); 
                    
                    if(logoutButton) logoutButton.style.display = 'none';
                    if(upgradeButton) upgradeButton.style.display = 'none';
                    if(loadHistoryButton) loadHistoryButton.style.display = 'none'; 
                    if(newChatButton) newChatButton.style.display = 'none';
                }
            });
        }

        function showAuthScreen(show) {
            authContainer.style.display = show ? 'flex' : 'none';
            chatContainer.style.display = show ? 'none' : 'flex';
        }
        
        // ------------------ FIRESTORE HISTORY LOGIC ------------------

        function getChatCollectionRef() {
            const collectionName = 'chat_history';
            const publicPath = `/artifacts/${appId}/public/data/${collectionName}`; 
            return collection(db, publicPath);
        }

        async function loadChatHistory() {
            if (!isPersistentUser(auth.currentUser) || !userId) {
                alertMessage('Ù†Û•ØªÙˆØ§Ù†Ø±Ø§ Ù…ÛÚ˜ÙˆÙˆ Ø¨Ø§Ø± Ø¨Ú©Ø±ÛØª', 'ØªÛ•Ù†Ù‡Ø§ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±Ø§Ù†ÛŒ Ø¨Û•Ø±Ø¯Û•ÙˆØ§Ù… (Ú¯ÙˆÙˆÚ¯Úµ) Ø¯Û•ØªÙˆØ§Ù†Ù† Ù…ÛÚ˜ÙˆÙˆÛŒ Ú†Ø§Øª Ø¨Ø§Ø± Ø¨Ú©Û•Ù†.');
                return;
            }
            
            loadHistoryButton.disabled = true;
            loadHistoryButton.innerHTML = '<i class="material-icons rotating-icon">sync</i> Ø¨Ø§Ø±Ú©Ø±Ø¯Ù†...';

            try {
                const q = query(
                    getChatCollectionRef(),
                    where('userId', '==', userId)
                );

                const querySnapshot = await getDocs(q);
                setupChatSession(auth.currentUser, true); 

                let chatMessages = [];
                let newChatHistory = [];

                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    if (data.timestamp && data.text && data.text !== WELCOME_MESSAGE_TEXT) {
                         chatMessages.push({ ...data, id: doc.id });
                    }
                });
                
                chatMessages.sort((a, b) => (a.timestamp?.toMillis() || 0) - (b.timestamp?.toMillis() || 0));

                chatMessages.forEach(msg => {
                    // Check if image data exists and display it
                    const imageUrl = msg.imageData ? `data:${msg.imageMimeType};base64,${msg.imageData}` : null;
                    appendMessage(msg.role, msg.text, false, imageUrl); 
                    
                    const apiRole = msg.role === 'ai' ? 'model' : 'user';
                    
                    const parts = [{ text: msg.text }];
                    if(imageUrl) {
                       parts.push({
                           inlineData: {
                               mimeType: msg.imageMimeType,
                               data: msg.imageData
                           }
                       });
                    }
                    newChatHistory.push({ role: apiRole, parts: parts });
                });

                window.chatHistory = newChatHistory; 

                messageArea.scrollTop = messageArea.scrollHeight;
                alertMessage('Ù…ÛÚ˜ÙˆÙˆ Ø¨Ø§Ø±Ú©Ø±Ø§', `Ø¨Û• Ø³Û•Ø±Ú©Û•ÙˆØªÙˆÙˆÛŒÛŒ ${chatMessages.length} Ù†Ø§Ù…Û• Ø¨Ø§Ø±Ú©Ø±Ø§.`);
                
            } catch (error) {
                console.error("Error loading chat history:", error);
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ø¨Ø§Ø±Ú©Ø±Ø¯Ù†', `Ú©ÛØ´Û•ÛŒÛ•Ú© Ù„Û• Ø¨Ø§Ø±Ú©Ø±Ø¯Ù†ÛŒ Ù…ÛÚ˜ÙˆÙˆÛŒ Ú†Ø§Øª Ú•ÙˆÙˆÛŒØ¯Ø§: ${error.message}`);
            } finally {
                loadHistoryButton.disabled = false;
                loadHistoryButton.innerHTML = '<i class="material-icons">history</i> Ø¨Ø§Ø±Ú©Ø±Ø¯Ù†ÛŒ Ù…ÛÚ˜ÙˆÙˆ';
            }
        }


        // ------------------ GEMINI CHAT LOGIC ------------------

        function setupChatSession(user, clearUI = true) {
            
            window.chatHistory = []; 
            if (clearUI) {
                messageArea.innerHTML = '';
            }
            removeImage(); // Clear any existing image preview
            appendMessage('ai', WELCOME_MESSAGE_TEXT, false);

            inputField.disabled = false;
            sendButton.disabled = false;
            inputField.value = '';
            autoResizeInput(); 
            inputField.focus();

            sendButton.onclick = sendMessage;
            inputField.onkeypress = (e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault(); 
                    sendMessage();
                }
            };
            inputField.addEventListener('input', autoResizeInput); 

            if (db && isPersistentUser(user)) {
                loadHistoryButton.onclick = loadChatHistory; 
            }
            newChatButton.onclick = startNewChat;
        }

        window.startNewChat = () => {
            if (auth.currentUser) {
                setupChatSession(auth.currentUser, true); 
                alertMessage('Ú†Ø§ØªÛŒ Ù†ÙˆÛ', 'Ú†Ø§ØªÛÚ©ÛŒ Ù†ÙˆÛ Ø¯Û•Ø³ØªÛŒÙ¾ÛÚ©Ø±Ø¯. Ù…ÛÚ˜ÙˆÙˆÛŒ Ú†Ø§ØªÛŒ Ù¾ÛØ´ÙˆÙˆ (Ø¦Û•Ú¯Û•Ø± Ù‡Û•Ø¨ÛØª) Ù„Û• ÙØ§ÛŒÛ•Ø±Ø¨Û•ÛŒØ³ Ù¾Ø§Ø±ÛØ²Ø±Ø§ÙˆÛ•.');
            }
        };


        /**
         * Function to create and append a new message to the chat.
         * @param {string} sender 'user' or 'ai'
         * @param {string} text The message text
         * @param {boolean} scroll Whether to scroll to the bottom
         * @param {string|null} imageUrl Optional Base64 image URL to display
         */
        function appendMessage(sender, text, scroll = true, imageUrl = null) {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', sender);
            
            const iconHTML = sender === 'ai' ? '<div class="icon">ğŸ¤–</div>' : '<div class="icon">Øª</div>';
            
            const contentDiv = document.createElement('div');
            contentDiv.classList.add('text-content');
            
            if (imageUrl) {
                 const img = document.createElement('img');
                 img.src = imageUrl;
                 img.alt = 'ÙˆÛÙ†Û•ÛŒ Ø¨Ø§Ø±Ú©Ø±Ø§Ùˆ';
                 img.classList.add('message-image');
                 // Wrap image content and text content for proper RTL display in AI bubble
                 if (sender === 'ai') {
                     contentDiv.appendChild(img);
                 } else {
                      // For user, image is part of the text-content
                      contentDiv.appendChild(img);
                 }
            }

            const textNode = document.createElement('p');
            textNode.innerHTML = text;
            contentDiv.appendChild(textNode);
            

            if (sender === 'ai') {
                const shouldShowTTS = text !== WELCOME_MESSAGE_TEXT && text.trim() !== '...' && text.trim().length > 0; 
                
                const bubbleContent = document.createElement('div');
                bubbleContent.classList.add('ai-bubble-content');
                
                // Add content
                bubbleContent.appendChild(contentDiv); 

                // Add TTS button
                if (shouldShowTTS) {
                    const ttsButton = document.createElement('button');
                    ttsButton.classList.add('tts-button');
                    ttsButton.innerHTML = '<i class="material-icons">volume_up</i> âœ¨Ú¯ÙˆÛÚ¯Ø±ØªÙ†';
                    ttsButton.title = 'Ú¯ÙˆÛÚ¯Ø±ØªÙ† Ø¨Û• Ø¯Û•Ù†Ú¯ÛŒ Ø¬ÛÙ…ÛŒÙ†ÛŒ';

                    ttsButton.onclick = () => window.playTTS(text, ttsButton);
                    
                    bubbleContent.appendChild(ttsButton);
                }

                messageDiv.innerHTML = iconHTML;
                messageDiv.appendChild(bubbleContent);
                messageDiv.style.alignSelf = 'flex-start'; 
                
                // If it's a loading state, return the text node for update
                if (text === '...') {
                    textNode.classList.add('loading-indicator');
                    return textNode;
                }
                
            } else {
                 messageDiv.innerHTML = contentDiv.outerHTML + iconHTML;
                 messageDiv.style.flexDirection = 'row-reverse';
                 messageDiv.style.alignSelf = 'flex-end';
            }
            
            messageArea.appendChild(messageDiv);
            if (scroll) {
                messageArea.scrollTop = messageArea.scrollHeight;
            }
            return textNode; // Return the text node for general message updates
        }

        async function sendMessage() {
            const prompt = inputField.value.trim();
            const hasImage = !!currentImageBase64;
            
            if (prompt === "" && !hasImage) return; 
            
            // --- CRITICAL API KEY CHECK (Prevents 400 if key is the placeholder) ---
            if (geminiApiKey === "YOUR_GEMINI_API_KEY_HERE" || !geminiApiKey || geminiApiKey.length < 30) {
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ API Key', 'ØªÚ©Ø§ÛŒÛ• Ú©Ù„ÛŒÙ„ÛŒ Ú•Ø§Ø³ØªÛ•Ù‚ÛŒÙ†Û•ÛŒ Gemini API Ø¬ÛÚ¯ÛŒØ± Ø¨Ú©Û• Ù„Û• Ú©Û†Ø¯ÛŒ Ø³Û•Ø±Û•ØªØ§Ø¯Ø§.');
                console.error("Gemini API key is missing or is the placeholder.");
                return;
            }

            const isPersistent = isPersistentUser(auth.currentUser);

            // 1. Construct user message parts
            const userParts = [{ text: prompt }];
            let imageSourceUrl = null;

            if (hasImage) {
                imageSourceUrl = `data:${currentImageMimeType};base64,${currentImageBase64}`;
                userParts.push({
                    inlineData: {
                        mimeType: currentImageMimeType,
                        data: currentImageBase64
                    }
                }
                );
            }
            
            // 2. Add user message to the UI
            appendMessage('user', prompt, true, imageSourceUrl);
            
            // 3. Add user message to local history
            window.chatHistory.push({ role: 'user', parts: userParts });
            
            // 4. Clean up input/image state
            inputField.value = '';
            autoResizeInput();
            removeImage(); // Clear image state after it has been added to history
            inputField.disabled = true;
            sendButton.disabled = true;
            
            // 5. Add a loading indicator for the AI's response
            const aiMessageTextNode = appendMessage('ai', '...');
            let aiResponseText = '';
            let aiResponseImage = null; // To store potential generated image

            // 6. SAVE USER MESSAGE TO FIRESTORE 
            if (userId && db && isPersistent) {
                 const firestoreData = {
                     userId: userId,
                     role: 'user',
                     text: prompt,
                     timestamp: serverTimestamp()
                 };
                 if(hasImage) {
                    firestoreData.imageData = currentImageBase64;
                    firestoreData.imageMimeType = currentImageMimeType;
                 }
                 try {
                     await addDoc(getChatCollectionRef(), firestoreData);
                 } catch (e) {
                     console.error("Error adding user message to history:", e);
                 }
            }
            
            try {
                // 7. Build Payload for direct fetch (Multi-modal)
                const payload = {
                    contents: window.chatHistory, 
                    tools: [{ google_search: {} }], 
                    systemInstruction: {
                        parts: [{ text: systemInstruction }] 
                    },
                    // Request the model to return an image if it deems necessary (e.g., editing/generation prompt)
                    generationConfig: {
                         responseModalities: ["TEXT", "IMAGE"]
                    }
                };
                
                // --- CRITICAL DEBUGGING STEP: Log the payload before sending ---
                console.log("--- DEBUG: Gemini API Request Payload ---");
                console.log(JSON.stringify(payload, null, 2));
                console.log("------------------------------------------");
                // --- END DEBUGGING STEP ---


                const chatApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${geminiApiKey}`;

                let response = null;
                let delay = 1000;
                for (let i = 0; i < 3; i++) {
                    try {
                        response = await fetch(chatApiUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        if (response.ok) break;
                    } catch (e) {
                        console.warn(`Gemini chat fetch failed (attempt ${i + 1}). Retrying in ${delay / 1000}s...`, e);
                    }
                    if (i < 2) await new Promise(resolve => setTimeout(resolve, delay *= 2));
                }

                if (!response || !response.ok) {
                    const errorText = await response.text();
                    console.error("API Response Text (for 400 error):", errorText);
                    throw new Error(`HTTP error! status: ${response.status}. Details in console.`);
                }
                const result = await response.json();
                
                // 8. Extract generated content (Text and Image)
                const candidate = result.candidates?.[0];
                const parts = candidate?.content?.parts;
                
                if (parts && parts.length > 0) {
                    
                    // Extract text part
                    const textPart = parts.find(p => p.text);
                    aiResponseText = textPart?.text || 'No text response generated.';
                    
                    // Extract image part (if generated)
                    const imagePart = parts.find(p => p.inlineData && p.inlineData.mimeType.startsWith('image/'));
                    if (imagePart) {
                        aiResponseImage = {
                            data: imagePart.inlineData.data,
                            mimeType: imagePart.inlineData.mimeType,
                            url: `data:${imagePart.inlineData.mimeType};base64,${imagePart.inlineData.data}`
                        };
                    }
                } else {
                    aiResponseText = 'No response generated.';
                }

                
                // 9. Add AI response to local history
                const aiParts = [];
                if (aiResponseText) aiParts.push({ text: aiResponseText });
                if (aiResponseImage) aiParts.push({ inlineData: { mimeType: aiResponseImage.mimeType, data: aiResponseImage.data } });
                
                // Only push to chat history if content was actually received
                if (aiParts.length > 0) {
                    window.chatHistory.push({ role: 'model', parts: aiParts });
                }


                // 10. Update UI (Remove loading, add final content)
                const parentMessage = aiMessageTextNode.closest('.message');
                if (parentMessage) {
                    // Remove loading message
                    parentMessage.remove(); 
                    
                    // Append the complete message
                    appendMessage('ai', aiResponseText, true, aiResponseImage ? aiResponseImage.url : null);
                }
                
                // 11. SAVE AI MESSAGE TO FIRESTORE
                if (userId && db && isPersistent) {
                      const firestoreData = {
                          userId: userId,
                          role: 'ai', 
                          text: aiResponseText,
                          timestamp: serverTimestamp()
                      };
                      if(aiResponseImage) {
                         firestoreData.imageData = aiResponseImage.data;
                         firestoreData.imageMimeType = aiResponseImage.mimeType;
                      }
                      try {
                          await addDoc(getChatCollectionRef(), firestoreData);
                      } catch (e) {
                          console.error("Error adding AI message to history:", e);
                      }
                }

            } catch (error) {
                console.error("Gemini API Error:", error);
                
                let errorMessage = `Ù‡Ù‡â€ŒÚµÙ‡â€Œ: Ø¨Ø¨ÙˆØ±Ù‡â€ŒØŒ Ù¾Ù‡â€ŒÛŒÙˆÙ‡â€ŒÙ†Ø¯ÛŒ Ù„Ù‡â€ŒÚ¯Ù‡â€ŒÚµ Ø¬ÛÙ…ÛŒÙ†ÛŒ Ù¾Ú†Ú•Ø§. Ù‡Û†Ú©Ø§Ø±: ${error.message}`;
                
                const parentMessage = aiMessageTextNode.closest('.message');
                if (parentMessage) {
                    // Find the text node and update it
                    parentMessage.querySelector('.loading-indicator').innerHTML = errorMessage;
                }
                // Also display an alert to the user for critical errors
                alertMessage('Ù‡Û•ÚµÛ•ÛŒ Ú¯Û•ÙˆØ±Û•', errorMessage);
            } finally {
                // 12. Re-enable input
                inputField.disabled = false;
                sendButton.disabled = false;
                inputField.focus();
                messageArea.scrollTop = messageArea.scrollHeight;
            }
        }

        // Start the application after the DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            const placeholder = document.getElementById('google-icon-placeholder');
            if (placeholder) {
                placeholder.innerHTML = emptyLogoHtml;
            }
            initializeFirebase();
        });

    </script>
</head>
<body>

    <!-- Authentication Screen (SHOWN BY DEFAULT) -->
    <div id="auth-container" class="auth-container" style="display: flex;">
        <div class="auth-card">
            <h2>Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ• Ø¨Û† Ø¦ÛŒØ¦Ø§ÛŒÛŒ Ú©ÙˆØ±Ø¯ÛŒ</h2>
            
            <!-- Google Sign-In -->
            <button id="google-sign-in" onclick="signInWithGoogle()" class="auth-button google-btn">
                Ú†ÙˆÙˆÙ†Û•Ú˜ÙˆÙˆØ±Û•ÙˆÛ• Ø¨Û• Ú¯ÙˆÙˆÚ¯Úµ
                <span id="google-icon-placeholder"></span>
            </button>

            <div class="separator">ÛŒØ§Ø®ÙˆØ¯</div>
            
            <!-- Anonymous Sign-In -->
            <button id="anonymous-sign-in" onclick="signInAnonymouslyUser()" class="auth-button anonymous-btn">
                <i class="material-icons">person_off</i>
                Ø¨Û• Ø¨ÛÙ†Ø§Ùˆ Ø¨Ú†Û† Ú˜ÙˆÙˆØ±Û•ÙˆÛ•
            </button>
            <p id="auth-error" class="text-xs text-red-500 mt-2"></p>
        </div>
    </div>


    <!-- Chat Interface (Hidden by default, shown only after successful sign-in) -->
    <div id="chat-container" class="chat-container" style="display: none;">
        
        <!-- Header/Toolbar -->
        <div class="header">
            <div class="title-group">
                <h1>Ø¦ÛŒØ¦Ø§ÛŒÛŒ Ú©ÙˆØ±Ø¯ÛŒ</h1>
                <div class="icon">â˜€ï¸</div>
            </div>
            <div class="header-actions">

                <!-- New Chat Button (Visible for ALL authenticated users) -->
                <button id="new-chat-button" onclick="startNewChat()" class="header-button" style="display: none;">
                    <i class="material-icons">add_box</i>
                    Ú†Ø§ØªÛŒ Ù†ÙˆÛ
                </button>

                <!-- Load History Button (Visible for Persistent users only, Hidden for Anonymous) -->
                <button id="load-history-button" class="header-button" style="display: none;">
                    <i class="material-icons">history</i>
                    Ø¨Ø§Ø±Ú©Ø±Ø¯Ù†ÛŒ Ù…ÛÚ˜ÙˆÙˆ
                </button>
                
                <!-- Link Google Button (Visible for Anonymous users only, Hidden for Persistent) -->
                <button id="upgrade-button" onclick="upgradeToGoogle()" class="header-button" style="display: none;">
                    <i class="material-icons">link</i>
                    Ø¨Û•Ø³ØªÙ†Û•ÙˆÛ• Ø¨Û• Ú¯ÙˆÙˆÚ¯Úµ
                </button>
                
                <!-- Logout Button (Visible for ALL authenticated users) -->
                <button id="logout-button" onclick="logout()" class="header-button" style="display: none;">
                    <i class="material-icons">logout</i>
                    Ú†ÙˆÙˆÙ†Û•Ø¯Û•Ø±Û•ÙˆÛ•
                </button>
            </div>
        </div>

        <!-- Message Display Area -->
        <div id="message-area" class="message-area">
            <!-- Chat messages will be appended here by JavaScript -->
        </div>

        <!-- Input Wrapper (Contains Preview and Input Bar) -->
        <div class="input-wrapper">
            
            <!-- Image Preview Area (Hidden by default) -->
            <div id="image-preview-container" class="relative" style="display: none;">
                <button id="remove-image-button" class="absolute top-1 right-1 bg-white rounded-full p-0.5 shadow-md">
                    <i class="material-icons text-red-500 text-lg">close</i>
                </button>
                <img id="image-preview" src="" alt="ÙˆÛÙ†Û•ÛŒ Ø¨Ø§Ø±Ú©Ø±Ø§Ùˆ" class="rounded-lg object-cover max-h-32"/>
                <span class="text-xs text-gray-500 mr-2">ÙˆÛÙ†Û•ÛŒ Ø¨Ø§Ø±Ú©Ø±Ø§Ùˆ:</span>
            </div>

            <!-- Input Bar -->
            <div class="input-area">
                <textarea id="user-input" rows="1" placeholder="Ù†Ø§Ù…Û• ÛŒØ§Ù† ÙÛ•Ø±Ù…Ø§Ù†ÛŒ ÙˆÛÙ†Û• Ù„ÛØ±Û• Ø¨Ù†ÙˆÙˆØ³Û•..."></textarea>
                
                <div class="input-controls">
                    <input type="file" accept="image/*" id="image-upload" hidden/>
                    
                    <!-- Upload Button -->
                    <button id="upload-button" onclick="document.getElementById('image-upload').click()" title="Ø¨Ø§Ø±Ú©Ø±Ø¯Ù†ÛŒ ÙˆÛÙ†Û•">
                        <i class="material-icons">image</i>
                    </button>
                    
                    <!-- Send Button -->
                    <button id="send-button">
                        <i class="material-icons">send</i>
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Footer/Status Info -->
        <div class="footer-info">
            <span id="user-id-display">Ù†Ø§Ø³Ù†Ø§Ù…Û•ÛŒ Ø¨Û•Ú©Ø§Ø±Ù‡ÛÙ†Û•Ø±: Ø¨ÛÙ†Ø§Ùˆ</span> |
            <span>Ú¯Û•Ø´Û•Ù¾ÛØ¯Ø±Ø§Ùˆ Ù„Û•Ú¯Û•Úµ Gemini & Firebase</span>
        </div>

    </div>
</body>
</html>
